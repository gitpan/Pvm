.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PVM 1 "perl " "19/Jun/96" "User Contributed Perl Documentation"
.IX Title "PVM 1"
.UC
.IX Name "Pvm - Perl extension for the Parallel Virtual Machine (PVM) Message Passing System"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
Pvm \- Perl extension for the Parallel Virtual Machine (PVM) Message Passing System
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 1
\&  use Pvm;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CWPVM\fR message passing system 
enables a programmer to configure a group of 
(possibly heterogenous) computers connected by 
a network into a 
parallel virtual machine.  
The system was developed by 
the University of Tennessee, Oak Ridge National 
Laboratory and Emory University. 
.PP
Using \f(CWPVM\fR, applications can 
be developed which spawns parallel processes onto 
nodes in the virtual machine to perform specific tasks.  
These parallel tasks can also periodically exchange 
information using a set of message passing functions 
developed for the system.  
.PP
\f(CWPVM\fR applications have mostly been developed in the scientific 
and engineering fields.  However applications 
for real-time and client/server systems can also be developed.  
\f(CWPVM\fR simply provides a convenient way for managing 
parallel tasks and communications  
without need for \f(CWrexec\fR or \f(CWsocket\fR level programming.
.PP
As a utility, \f(CWPVM\fR enables an organisation to leverage on the computers 
already available for parallel processing.  
Parallel applications can be started during non-peak 
hours to utilise idle CPU cycles.  
Or dedicated workstation clusters connected via 
a high performance network like \f(CWATM\fR can be used for high 
performance computing.  
.PP
It is recommended that you read the \f(CWPVM\fR manual pages and the book
\f(CWPVM: Parallel Virtual Machine, A users's guide and tutorial 
for networked parallel computing\fR.  Both the \f(CWPVM\fR system and the 
book can be obtained by email from \f(CWnetlib@ornl.gov\fR 
or anonymous ftp from \f(CWnetlib2.cs.utk.edu\fR.  
.PP
For the rest of 
this document we will provide a tutorial introduction to 
developing \f(CWPVM\fR applications using perl.  The interface for some 
of the \f(CWPVM\fR functions have been changed of course to give it a 
more perl-like feel.  
.PP
Remember think perl think parallel!  Good Luck!  
.Sh "Environment Variables"
.IX Subsection "Environment Variables"
After installing \f(CWPVM\fR on your computer, there are two mandatory 
environment variables that have to be set in your .login or .cshrc
files; \f(CWPVM_ROOT\fR and \f(CWPVM_ARCH\fR.  
\f(CWPVM_ROOT\fR points to the base of the \f(CWPVM\fR 
installation directory, and \f(CWPVM_ARCH\fR specifies the architecture 
of the computer on which \f(CWPVM\fR is running.   An example of how this can 
be set for csh is shown below,
.PP
.Vb 2
\&        setenv PVM_ROOT /usr/local/pvm3
\&        setenv PVM_ARCH `$PVM_ROOT/lib/pvmgetarch`
.Ve
.Sh "Setting up your rsh permission"
.IX Subsection "Setting up your rsh permission"
In order for \f(CWPVM\fR applications to run, \f(CWrsh\fR permission 
has to be enabled.  This involves creating a \f(CW.rhosts\fR 
file in your \f(CWHOME\fR directory containing, for each line, the host and 
account name you wish to allow remote execution privillages.
An example \f(CW.rhosts\fR file to allow a \f(CWPVM\fR application to 
remotely execute on the host \f(CWonyx\fR and \f(CWprata\fR using the 
account \f(CWedward\fR is shown below,
.PP
.Vb 2
\&        onyx    edward
\&        prata   edward
.Ve
.Sh "Configuring your parallel virtual machine"
.IX Subsection "Configuring your parallel virtual machine"
Parallel process management and communications is handled by a set of 
distributed deamons running on each of the nodes of the 
virtual machine.  The daemon executable, \f(CWpvmd\fR, is started 
when a computer is added to the virtual machine.  
A computer can be added to the virtual machine either statically 
in a console program or using a \f(CWhostfile\fR, 
or dynamically within the application code itself.
.PP
The first method of configuring your virtual machine 
is to use the console program \f(CW$PVM_ROOT/lib/pvm\fR.  
Run it from the command prompt.  The console program will first add the 
local host into the virtual machine and display the prompt 
	
	pvm>
.PP
To add a host, eg \f(CWonyx\fR, as a node in your parallel virtual machine, simply
type
.PP
.Vb 1
\&        pvm> add onyx
.Ve
To display the current virtual machine configuration type
.PP
.Vb 1
\&        pvm> conf
.Ve
which will display node information pertaining to the host name, 
host id, host architecture, relative speed and data format.  
The console program has a number of other commands which can 
be viewed by typing \f(CWhelp\fR.  
.PP
The second method of configuring your virtual machine is to use 
a \f(CWhostfile\fR.   The \f(CWhostfile\fR is simply an \s-1ASCII\s0 text file 
specifing the host names of the computers to be added into your 
virtual machine.  
.PP
Additional options may be also be defined 
for the nodes pertaining to the working directory, 
execution path, login name, alternative hostname etc. A simple
example of a \f(CWhostfile\fR is shown below. 
.PP
.Vb 4
\&        * wd=$HOME/work ep=$HOME/bin
\&        onyx
\&        prata.nsrc.nus.sg
\&        laksa ep=$HOME/perl5/bin
.Ve
In the above example \f(CWhostfile\fR we are adding the 
hosts \f(CWonyx\fR, \f(CWprata.nsrc.nus.sg\fR and \f(CWlaksa\fR into the 
virtual machine. We are also specifying the working 
directory, \f(CWwd\fR, in which we want our application 
to run, and the execution path, \f(CWep\fR, in which we want \f(CWPVM\fR
to look for executables. 
.PP
The \f(CW*\fR in the first line 
defines a global option for all the hosts specified after it.
We can however provide an option locally to over-ride this
global option.  This is seen for the host \f(CWlaksa\fR where 
we have specified its execution path to be \f(CW$HOME/perl5/bin\fR 
instead of the \f(CW$HOME/bin\fR.  
.PP
The third method of configuring your virtual machine 
is to call the functions \f(CWPvm::addhosts\fR or \f(CWPvm::delhosts\fR 
within your application.  You must still start your master
\f(CWpvmd\fR daemon first. This can be achieved by starting 
\f(CWpvm\fR and typing \f(CWquit\fR or simply typing  
.PP
.Vb 1
\&        echo quit | pvm
.Ve
The \f(CWPVM\fR application can then be started where 
we can add the hosts \f(CWprata.nsrc.nus.sg\fR and \f(CWlaksa\fR by calling
.PP
.Vb 1
\&        Pvm::addhosts("prata.nsrc.nus.sg","laksa");
.Ve
Or we can delete a host from our configuration by calling 
.PP
.Vb 1
\&        Pvm::delhosts("laksa");
.Ve
\f(CWPVM\fR also provides a function, \f(CWPvm::conf\fR, to query the configuration 
of the parallel virtual machine. An example code to check the current 
configuration is shown below.
.PP
.Vb 9
\&        ($info,@conf) = Pvm::conf ;
\&        if ( $info == PvmOk ){
\&           foreach $node (@conf){
\&              print "host id = $node->{'hi_tid'}\en";
\&              print "host name = $node->{'hi_name'}\en";
\&              print "host architecture = $node->{'hi_arch'}\en";
\&              print "host speed = $node->{'hi_speed'}\en";
\&           }
\&        }
.Ve
.Sh "Enrolling a task into \s-1PVM\s0"
.IX Subsection "Enrolling a task into \s-1PVM\s0"
A task has to expilictly enroll into \f(CWPVM\fR 
in order for it to be known by other \f(CWPVM\fR tasks.  
This can often be done by the call 
	
	\f(CW$mytid\fR = Pvm::mytid ;
.PP
where \f(CW$mytid\fR is the task id, \f(CWTID\fR, assigned by the 
\f(CWPVM\fR system to the calling process.  Note however that 
calling any \f(CWPVM\fR function in a program will also enroll it 
into the system.  
.Sh "Spawning parallel tasks"
.IX Subsection "Spawning parallel tasks"
A \f(CWPVM\fR application can spawn parallel tasks in your parallel 
virtual machine.  Assuming there is exists an executable called 
\f(CWclient\fR, we can spawn four \f(CWclient\fR tasks in our virtual 
machine by calling 
.PP
.Vb 1
\&        ($ntask,@tids) = Pvm::spawn("client",4);
.Ve
For each of the four spawned processes, the \s-1PVM\s0 system first 
allocates a host node and looks for the executable in the 
execuation path of that host.  If the executable is found it 
is started.  
.PP
The task which called the \f(CWPvm::spawn\fR is known as 
the \f(CWparent\fR task.  
The number of \f(CWchildren\fR tasks which are actually spawned by 
\f(CWPvm::spawn\fR is returned in the scalar \f(CW$ntask\fR.  
The \f(CW@tids\fR array returns the task id, \f(CWTID\fR, of the spawned 
\f(CWchildren\fR tasks which will be useful later for 
communicating with them.  A \f(CWTID\fR < 0 indicates a task failure 
to spawn and can be used to determine the nature of 
the problem.  Eg.
.PP
.Vb 7
\&        foreach $tid (@tids){
\&           if ( $tid < 0 ){
\&              if ( $tid == PvmNoMem )
\&                 warn "no memory ! \en";
\&              }else if ( $tid == PvmSysErr ){
\&                 warn "pvmd not responding ! \en";
\&              } ... 
.Ve
.Vb 2
\&           }
\&        }
.Ve
For more sophisticated users, \f(CWPvm::spawn\fR may be given additional 
argument parameters to control how/where you want a task to be spawned.
For example, you can specifically spawn \f(CWclient\fR in the internet 
host <onyx.nsrc.nus.sg> by calling
.PP
.Vb 1
\&        Pvm::spawn("client",1,PvmTaskHost,"onyx.nsrc.nus.sg");
.Ve
Or you can spawn \f(CWclient\fR on host nodes only of a particular architecture, 
say \s-1RS6K\s0 workstations, by calling
.PP
.Vb 1
\&        Pvm::spawn("client",4,PvmTaskArch,"RS6K");
.Ve
Note that tasks which have been spawned by using \f(CWPvm::spawn\fR 
do not need to be explicitly enrolled into the pvm system.  
.Sh "Exchanging messages between tasks"
.IX Subsection "Exchanging messages between tasks"
Messages can be sent to a task enrolled into \f(CWPVM\fR by specifying 
the example code sequence
.PP
.Vb 4
\&        Pvm::initsend ;
\&        Pvm::pack(2.345,"hello dude");
\&        Pvm::pack(1234);
\&        Pvm::send($dtid,999);
.Ve
In our example we first call \f(CWPvm::initsend\fR to initialize 
the internal \f(CWPVM\fR send buffer.  
We then call \f(CWPvm::buffer\fR to fill this buffer with a double (2.345),
, a string ("hello dude"), and an integer (1234).  
Having filled the send buffer with the data that is to be sent, 
we call \f(CWPvm::send\fR to do the actual send to the task identifed by the \f(CWTID\fR 
\f(CW$dtid\fR.   We also label the sending message to disambiguate it with 
other messages with a tag.  This is done with the 999 argument in 
\f(CWPvm::send\fR function.  
.PP
For the destination task, we can receive the message sent by 
performing a blocking receive with the function \f(CWPvm::recv\fR.  
A code sequence for the above example on the recipent 
end will be 
.PP
.Vb 4
\&        if ( Pvm::recv >= 0 ){
\&           $int_t = Pvm::unpack ;
\&           ($double_t,$str_t) = Pvm::unpack ;
\&        }
.Ve
Note that we must unpack the message in the reverse order in which we packed 
our message.  
In our example \f(CWPvm::recv\fR will receive any message sent to it.  
In order to selectively receive a message, we could specify 
the \f(CWTID\fR of the source task and the message \f(CWtag\fR.  For
example, 
.PP
.Vb 2
\&        $tag = 999;
\&        Pvm::recv($stid,$tag) ;
.Ve
Other message passing functions that you may find useful are 
\f(CWPvm::psend\fR, \f(CWPvm::trecv\fR, \f(CWPvm::nrecv\fR and \f(CWPvm::precv\fR.  
.Sh "Parallel I/O "
.IX Subsection "Parallel I/O "
Note that the file descriptors in a parent task are not
inherented in the spawned \f(CWchildren\fR tasks unlike \f(CWfork\fR.  
By default any file I/O will be performed in the working 
directory specified in the \f(CWhostfile\fR if no 
absolute path was provided for the opened file.  
If no working directory is specified, the default is the 
\f(CW$HOME\fR directory.  For directories which are not \s-1NFS\s0 mounted, 
this would mean that each task performs its own separate 
I/O.  
.PP
In the case of \f(CWtty\fR output, tasks which are not 
started from the command prompt will have their 
\f(CWstdout\fR and \f(CWstderr\fR directed to the file pvml.<uid>.  
This may be redirected to a \f(CWparent\fR task by 
calling 
.PP
.Vb 1
\&        Pvm::catchout;
.Ve
for \f(CWstdout\fR or 
.PP
.Vb 1
\&        Pvm::catchout(stderr);
.Ve
for \f(CWstderr\fR.   You can direct the \f(CWstdout\fR or \f(CWstderr\fR output 
of a task to another \f(CWTID\fR , other then its parent, by calling 
.PP
.Vb 1
\&        Pvm::setopt(PvmOutTid,$tid);
.Ve
.Sh "Incorporating fault tolerance"
.IX Subsection "Incorporating fault tolerance"
The function \f(CWPvm::notify\fR can be used to incorporate some 
fault tolerance into your \s-1PVM\s0 application.  
You may use it to ask the \f(CWPVM\fR 
to monitor the liveliness of a set of hosts or tasks
during the execution of a \s-1PVM\s0 application. 
For example you can instrument 
your application to monitor 3 tasks with \f(CWTID\fR \f(CW$task1\fR, 
\f(CW$task2\fR, and \f(CW$task3\fR, by using the code segments 
.PP
.Vb 3
\&        @monitor = ($task1,$task2,$task3);
\&        Pvm::notify(PvmTaskExit,999,@monitor_task);
\&        ...
.Ve
.Vb 4
\&        if ( Pvm::probe(-1,999) ){
\&           $task = Pvm::recv_notify ;
\&           print "Oops! task $task has failed ... \en" ; 
\&        }
.Ve
If either \f(CW$task1\fR, \f(CW$task2\fR or \f(CW$task3\fR 
fails,  the notification will take the form of 
a single message with the 
tag 999.  The message content will inform you of 
the \f(CWTID\fR of the failed task.  
.PP
A similar scheme may be employed for the notification of host 
failures in your parallel virtual machine.  
.Sh "Client/Server example"
.IX Subsection "Client/Server example"
\f(CWClient:\fR
.PP
.Vb 3
\&        use Pvm;
\&        use File::Basename;
\&        ...
.Ve
.Vb 2
\&        # Look for server tid and assume 
\&        # server name is 'service_provider'
.Ve
.Vb 7
\&        @task_list = Pvm::tasks ;
\&        foreach $task (@task_list){
\&           $a_out = $task->{'ti_a_out'} ;
\&           $base = basename $a_out ;
\&           if ( $base eq 'service_provider' )
\&                $serv_tid = $task->{'ti_tid'} ;
\&        }
.Ve
.Vb 4
\&        # This is just one way (not necessarily the
\&        # best) of getting a server tid.
\&        # You could do the same thing by reading 
\&        # the server tid posted in a file. 
.Ve
.Vb 4
\&        ...
\&        
\&        # send request for service
\&        Pvm::send($serv_tid,$REQUEST);
.Ve
.Vb 4
\&        # receive service from server
\&        Pvm::recv(-1,$RESPONSE);
\&        @service_packet = Pvm::unpack ;
\&        ...
.Ve
\f(CWServer:\fR
.PP
.Vb 2
\&        while(1){
\&           ...
.Ve
.Vb 1
\&           if ( Pvm::probe(-1,$REQUEST) ){
.Ve
.Vb 3
\&              # a service request has arrived !
\&              $bufid = Pvm::recv ;
\&              ($info,$bytes,$tag,$stid) = Pvm::bufinfo($bufid) ;
.Ve
.Vb 16
\&              if ( fork == 0 ){
\&                 # fork child process to handle service
\&                 ...
\& 
\&                 # provide service
\&                 Pvm::initsend ;
\&                 Pvm::pack(@service);
\&                 Pvm::send($stid,$RESPONSE);
\&                 
\&                 # exit child process
\&                 exit ;
\&              }
\&           }       
\&           ...
\&        
\&        }
.Ve
.Sh "\s-1PVM\s0 groups "
.IX Subsection "\s-1PVM\s0 groups "
The \s-1PVM\s0 dynamic group functions have not been ported to perl yet.  
These functions provide facilities for collecting processes under 
a single \f(CWgroup\fR label, and applying aggregate operations onto 
them.  Examples of these functions are \f(CWPvm::barrier\fR, \f(CWPvm::reduce\fR, 
\f(CWPvm::bcast\fR etc.  
One of our concerns is that these group functions may be 
changed or augmented in the future releases of \s-1PVM\s0 3.4*. A decision 
for porting the group functions will be made after 
\s-1PVM\s0 3.4 has been released.  
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.Ip "\f(CWPvm::addhosts\fR " 0
.IX Item "\f(CWPvm::addhosts\fR "
Adds one or more host names to a parallel virtual machine. Eg.
.PP
.Vb 1
\&        $info = Pvm::addhosts(@host_list) ;
.Ve
.Ip "\f(CWPvm::bufinfo\fR" 0
.IX Item "\f(CWPvm::bufinfo\fR"
Returns information about the requested message buffer. Eg.
.PP
.Vb 1
\&        ($info,$bytes,$tag,$tid) = Pvm::bufinfo($bufid);
.Ve
.Ip "\f(CWPvm::catchout\fR" 0
.IX Item "\f(CWPvm::catchout\fR"
Catches output from children tasks.  Eg.
.PP
.Vb 2
\&        # Pvm::catchout(stdout);
\&        $bufid = Pvm::catchout; 
.Ve
.Ip "\f(CWPvm::config\fR" 0
.IX Item "\f(CWPvm::config\fR"
Returns information about the present virtual machine configuration. Eg.
.PP
.Vb 1
\&        ($info,@host_ref_list) = Pvm::config ;
.Ve
.Ip "\f(CWPvm::delhosts\fR" 0
.IX Item "\f(CWPvm::delhosts\fR"
Deletes one or more hosts from the virtual machine. Eg.
.PP
.Vb 1
\&        $info = Pvm::delhosts(@host_list);
.Ve
.Ip "\f(CWPvm::exit\fR" 0
.IX Item "\f(CWPvm::exit\fR"
Tells the local \s-1PVM\s0 daemon that the process is leaving.  Eg.
.PP
.Vb 1
\&        $info = Pvm::exit ;
.Ve
.Ip "\f(CWPvm::freebuf\fR" 0
.IX Item "\f(CWPvm::freebuf\fR"
Disposes of a message buffer. Eg.
.PP
.Vb 1
\&        $info = Pvm::freebuf($bufid);
.Ve
.Ip "\f(CWPvm::getopt\fR" 0
.IX Item "\f(CWPvm::getopt\fR"
Shows various libpvm options.  Eg.
.PP
.Vb 2
\&        $val = Pvm::getopt(PvmOutputTid);
\&        $val = Pvm::getopt(PvmFragSize);
.Ve
.Ip "\f(CWPvm::getrbuf\fR" 0
.IX Item "\f(CWPvm::getrbuf\fR"
Returns the message buffer identifier for the active receive buffer. Eg.
.PP
.Vb 1
\&        $bufid = Pvm::getrbuf ;
.Ve
.Ip "\f(CWPvm::getsbuf\fR" 0
.IX Item "\f(CWPvm::getsbuf\fR"
Returns the message buffer identifier for the active send buffer.  Eg. 
.PP
.Vb 1
\&        $bufid = Pvm::getsbuf ;
.Ve
.Ip "\f(CWPvm::halt\fR" 0
.IX Item "\f(CWPvm::halt\fR"
Shuts down the entire \s-1PVM\s0 system. Eg. 
.PP
.Vb 1
\&        $info = Pvm::halt ;
.Ve
.Ip "\f(CWPvm::hostsync\fR" 0
.IX Item "\f(CWPvm::hostsync\fR"
Gets time-of-day clock from \s-1PVM\s0 host. Eg.
.PP
.Vb 1
\&        ($info,$remote_clk,$delta) = Pvm::hostsync($host) ;
.Ve
where \f(CWdelta\fR is the time-of-day equivalent to \f(CWlocal_clk - remote_clk\fR. 
.Ip "\f(CWPvm::initsend\fR" 0
.IX Item "\f(CWPvm::initsend\fR"
Clears default send buffer and specifies message encoding. Eg.
.PP
.Vb 2
\&        # Pvm::initsend(PvmDataDefault) ;
\&        $bufid = Pvm::initsend
.Ve
.Ip "\f(CWPvm::kill\fR" 0
.IX Item "\f(CWPvm::kill\fR"
Terminates a specified \s-1PVM\s0 process.
.PP
.Vb 1
\&        $info = Pvm::kill($tid);
.Ve
.Ip "\f(CWPvm::mcast\fR" 0
.IX Item "\f(CWPvm::mcast\fR"
Multicast the data in the active message buffer to a set of tasks.  Eg.
.PP
.Vb 1
\&        $info = Pvm::mcast(@tid_list,$tag);
.Ve
.Ip "\f(CWPvm::mkbuf\fR" 0
.IX Item "\f(CWPvm::mkbuf\fR"
Creates a new message buffer. Eg.
.PP
.Vb 2
\&        # Pvm::mkbuf(PvmDataDefault);
\&        $bufid = Pvm::mkbuf ;
.Ve
.Vb 1
\&        $bufid = Pvm::mkbuf(PvmDataRaw);
.Ve
.Ip "\f(CWPvm::mstat\fR" 0
.IX Item "\f(CWPvm::mstat\fR"
Returns the status of a host in the virtual machine.  Eg. 
.PP
.Vb 1
\&        $status = Pvm::mstat($host);
.Ve
.Ip "\f(CWPvm::mytid\fR" 0
.IX Item "\f(CWPvm::mytid\fR"
Returns the tid of the calling process.
.PP
.Vb 1
\&        $mytid = Pvm::mytid ;
.Ve
.Ip "\f(CWPvm::notify\fR" 0
.IX Item "\f(CWPvm::notify\fR"
Requests notification of \s-1PVM\s0 events. Eg.
.PP
.Vb 1
\&        $info = Pvm::notify(PvmHostDelete,999,$host_list);
.Ve
.Ip "\f(CWPvm::nrecv\fR" 0
.IX Item "\f(CWPvm::nrecv\fR"
Nonblocking receive.  Eg.
.PP
.Vb 2
\&        # Pvm::nrecv(-1,-1);
\&        $bufid = Pvm::nrecv ;
.Ve
.Vb 2
\&        # Pvm::nrecv($tid,-1);
\&        $bufid = Pvm::nrecv($tid) ;
.Ve
.Vb 1
\&        $bufid = Pvm::nrecv($tid,$tag) ;
.Ve
.Ip "\f(CWPvm::pack\fR" 0
.IX Item "\f(CWPvm::pack\fR"
Packs active message buffer with data. Eg.
.PP
.Vb 1
\&        $info = Pvm::pack(@data_list);
.Ve
.Ip "\f(CWPvm::parent\fR" 0
.IX Item "\f(CWPvm::parent\fR"
Returns the tid of the process that spawned the calling process.  Eg.
.PP
.Vb 1
\&        $tid = Pvm::parent ;
.Ve
.Ip "\f(CWPvm::perror\fR" 0
.IX Item "\f(CWPvm::perror\fR"
Prints the error status of the las \s-1PVM\s0 call.
.PP
.Vb 1
\&        $info = Pvm::perror($msg);
.Ve
.Ip "\f(CWPvm::precv\fR" 0
.IX Item "\f(CWPvm::precv\fR"
Receives a message directly into a buffer.  
.PP
.Vb 2
\&        # Pvm::precv(-1,-1);
\&        @recv_buffer = Pvm::precv ;
.Ve
.Vb 2
\&        # Pvm::precv($tid,-1);
\&        @recv_buffer = Pvm::precv($tid);
.Ve
.Vb 1
\&        @recv_buffer = Pvm::precv($tid,$tag);
.Ve
Note that the current limit for the receive buffer is 100 KBytes.  
.Ip "\f(CWPvm::probe\fR" 0
.IX Item "\f(CWPvm::probe\fR"
Checks whether a message has arrived.  Eg.
.PP
.Vb 2
\&        # Pvm::probe(-1,-1);
\&        $bufid = Pvm::probe ;
.Ve
.Vb 2
\&        # Pvm::probe($tid,-1);
\&        $bufid = Pvm::probe($tid);
.Ve
.Vb 1
\&        $bufid = Pvm::probe($tid,$tag);
.Ve
.Ip "\f(CWPvm::psend\fR" 0
.IX Item "\f(CWPvm::psend\fR"
Packs and sends data in one call.  Eg.
.PP
.Vb 1
\&        $info = Pvm::psend($tid,$tag,@send_buffer);
.Ve
.Ip "\f(CWPvm::pstat\fR" 0
.IX Item "\f(CWPvm::pstat\fR"
Returns the status of the specified \s-1PVM\s0 process.  Eg.
.PP
.Vb 1
\&        $status = Pvm::pstat($tid);
.Ve
.Ip "\f(CWPvm::recv\fR" 0
.IX Item "\f(CWPvm::recv\fR"
Receives a message.  Eg.
.PP
.Vb 2
\&        # Pvm::recv(-1,-1);
\&        $bufid = Pvm::recv ;
.Ve
.Vb 2
\&        # Pvm::recv($tid,-1);
\&        $bufid = Pvm::recv($tid) ;
.Ve
.Vb 1
\&        $bufid = Pvm::recv($tid,$tag);
.Ve
.Ip "\f(CWPvm::recvf\fR" 0
.IX Item "\f(CWPvm::recvf\fR"
Redefines the comparison function used to accept messages.  Eg.
.PP
.Vb 1
\&        Pvm::recvf(\e&new_foo);
.Ve
.Ip "\f(CWPvm::recv_notify\fR" 0
.IX Item "\f(CWPvm::recv_notify\fR"
Receives the notification message initiated by \f(CWPvm::notify\fR.  This 
should be preceded by a \f(CWPvm::probe\fR.  Eg.
.PP
.Vb 3
\&        if ( Pvm::probe(-1,$notify_tag) ){
\&                $message = Pvm::recv_notify ;
\&        }
.Ve
.Ip "\f(CWPvm::recvf_old\fR" 0
.IX Item "\f(CWPvm::recvf_old\fR"
Resets the comparison function for accepting messages to the 
previous method before a call to \f(CWPvm::recf\fR.  
.Ip "\f(CWPvm::reg_hoster\fR" 0
.IX Item "\f(CWPvm::reg_hoster\fR"
Registers this task as responsible for adding new \s-1PVM\s0 hosts.  Eg.
.PP
.Vb 1
\&        $info = Pvm::reg_hoster ;
.Ve
.Ip "\f(CWPvm::reg_rm\fR" 0
.IX Item "\f(CWPvm::reg_rm\fR"
Registers this task as a \s-1PVM\s0 resource manager.  Eg.
.PP
.Vb 1
\&        $info = Pvm::reg_rm ;
.Ve
.Ip "\f(CWPvm::reg_tasker\fR" 0
.IX Item "\f(CWPvm::reg_tasker\fR"
Registers this task as responsible for starting new \s-1PVM\s0 tasks.  Eg.
.PP
.Vb 1
\&        $info = Pvm::reg_tasker ;
.Ve
.Ip "\f(CWPvm::send\fR" 0
.IX Item "\f(CWPvm::send\fR"
Send the data in the active message buffer.  Eg.  
.PP
.Vb 2
\&        # Pvm::send(-1,-1);
\&        $info = Pvm::send ;
.Ve
.Vb 2
\&        # Pvm::send($tid,-1);
\&        $info = Pvm::send($tid);
.Ve
.Vb 1
\&        $info = Pvm::send($tid,$tag);
.Ve
.Ip "\f(CWPvm::sendsig\fR" 0
.IX Item "\f(CWPvm::sendsig\fR"
Sends a signal to another \s-1PVM\s0 process.  Eg.
.PP
.Vb 2
\&        use POSIX qw(:signal_h);
\&        ...
.Ve
.Vb 1
\&        $info = Pvm::sendsig($tid,SIGKILL);
.Ve
.Ip "\f(CWPvm::setopt\fR" 0
.IX Item "\f(CWPvm::setopt\fR"
Sets various libpvm options.  Eg.
.PP
.Vb 1
\&        $oldval=Pvm::setopt(PvmOutputTid,$val);
.Ve
.Vb 1
\&        $oldval=Pvm::setopt(PvmRoute,PvmRouteDirect);
.Ve
.Ip "\f(CWPvm::setrbuf\fR " 0
.IX Item "\f(CWPvm::setrbuf\fR "
Switches the active receive buffer and saves the previous buffer.  Eg.
.PP
.Vb 1
\&        $oldbuf = Pvm::setrbuf($bufid);
.Ve
.Ip "\f(CWPvm::setsbuf\fR" 0
.IX Item "\f(CWPvm::setsbuf\fR"
Switches the active send buffer.  Eg.
.PP
.Vb 1
\&        $oldbuf = Pvm::setsbuf($bufid);
.Ve
.Ip "\f(CWPvm::spawn\fR" 0
.IX Item "\f(CWPvm::spawn\fR"
Starts new \s-1PVM\s0 processes.  Eg.
.PP
.Vb 2
\&        # Pvm::spawn("compute.pl",4,PvmTaskDefault,"");
\&        ($ntask,@tid_list) = Pvm::spawn("compute.pl",4);
.Ve
.Vb 1
\&        ($ntask,@tid_list) = Pvm::spawn("compute.pl",4,PvmTaskHost,"onyx");
.Ve
.Ip "\f(CWPvm::tasks\fR" 0
.IX Item "\f(CWPvm::tasks\fR"
Returns information about the tasks running on the virtual machine. Eg.
.PP
.Vb 2
\&        # Pvm::tasks(0); Returns all tasks
\&        ($info,@task_list) = Pvm::tasks ;
.Ve
.Vb 3
\&        # Returns only for task $tid 
\&        ($info,@task_list) = Pvm::tasks($tid) ;
\&        
.Ve
.Ip "\f(CWPvm::tidtohost\fR" 0
.IX Item "\f(CWPvm::tidtohost\fR"
Returns the host \s-1ID\s0 on which the specified task is running.  Eg.
.PP
.Vb 1
\&        $dtid = Pvm::tidtohost($tid);
.Ve
.Ip "\f(CWPvm::trecv\fR" 0
.IX Item "\f(CWPvm::trecv\fR"
Receive with timeout.  Eg.
.PP
.Vb 2
\&        # Pvm::trecv(-1,-1,1,0); time out after 1 sec
\&        $bufid = Pvm::trecv ;
.Ve
.Vb 2
\&        # time out after 2*1000000 + 5000 usec  
\&        $bufid = Pvm::trecv($tid,$tag,2,5000);
.Ve
.Ip "\f(CWPvm::unpack\fR" 0
.IX Item "\f(CWPvm::unpack\fR"
Unpacks the active receive message buffer.  Eg.
.PP
.Vb 1
\&        @recv_buffer = Pvm::unpack ;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Edward Walker, edward@nsrc.nus.sg,
National Supercomputing Research Centre
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\fIperl\fR\|(1), \fIpvm_intro\fR\|(1PVM)

.rn }` ''
